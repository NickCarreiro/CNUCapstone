<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ title or "FileFort" }}</title>
    <script>
      (function () {
        const root = document.documentElement;
        root.classList.add("vp-pending");

        function applyViewportMetrics() {
          const vv = window.visualViewport;
          const width = Math.max(Math.round(vv ? vv.width : window.innerWidth || 0), 320);
          const height = Math.max(Math.round(vv ? vv.height : window.innerHeight || 0), 320);
          root.style.setProperty("--app-vw", `${width}px`);
          root.style.setProperty("--app-vh", `${height}px`);

          const header = document.querySelector(".site-header");
          const footer = document.querySelector(".site-footer");
          const headerHeight = header ? Math.ceil(header.getBoundingClientRect().height) : 0;
          const footerHeight = footer ? Math.ceil(footer.getBoundingClientRect().height) : 0;
          root.style.setProperty("--app-header-h", `${headerHeight}px`);
          root.style.setProperty("--app-footer-h", `${footerHeight}px`);
        }

        function markReady() {
          root.classList.remove("vp-pending");
          root.classList.add("vp-ready");
        }

        function bootstrapViewport() {
          applyViewportMetrics();
          markReady();
        }

        applyViewportMetrics();
        if (!window.matchMedia("(max-width: 760px)").matches) {
          markReady();
        }

        if (document.readyState === "loading") {
          document.addEventListener(
            "DOMContentLoaded",
            () => {
              requestAnimationFrame(bootstrapViewport);
            },
            { once: true }
          );
        } else {
          requestAnimationFrame(bootstrapViewport);
        }

        window.addEventListener("resize", applyViewportMetrics, { passive: true });
        window.addEventListener(
          "orientationchange",
          () => {
            requestAnimationFrame(applyViewportMetrics);
          },
          { passive: true }
        );

        if (window.visualViewport) {
          window.visualViewport.addEventListener("resize", applyViewportMetrics, { passive: true });
        }
      })();
    </script>
    <link rel="stylesheet" href="/static/style.css?v=20" />
  </head>
  <body data-theme="light" class="{% block body_class %}{% endblock %}">
    <div class="page">
      <header class="site-header">
        <div class="container header-inner">
          <div class="brand-group">
            <div class="brand">FileFort</div>
            <div class="brand-sub">Single-host secure storage</div>
          </div>
          <div class="toolbar">
            {% if user %}
            <nav class="nav" id="pfvPrimaryNav">
              <button type="button" class="nav-pill" id="pfvTerminalNav">Terminal</button>
              <a href="/ui">Dashboard</a>
              <a href="/ui/groups" class="nav-link-with-badge" id="pfvNavGroupsLink">
                <span>Groups</span>
                <span class="nav-count" id="pfvNavBadgeGroups" hidden>0</span>
              </a>
              <a href="/ui/audit">Audit</a>
              <a href="/ui/trash">Trash</a>
              {% if user.is_admin %}
              <a href="/ui/admin/users">Admin</a>
              <a href="/ui/admin/audit">Admin Audit</a>
              {% endif %}
            </nav>
            <div class="toolbar-actions">
              <button type="button" class="ghost nav-menu-toggle" id="pfvMenuToggle" aria-expanded="false" aria-controls="pfvPrimaryNav">Menu</button>
              <div class="user-pill">Signed in as {{ user.username }}</div>
              <button type="button" class="ghost toggle-theme" id="themeToggle">Dark mode</button>
              <a class="pill ghost-link" href="/ui/logout">Logout</a>
            </div>
            {% else %}
            <div class="toolbar-actions">
              <button type="button" class="ghost toggle-theme" id="themeToggle">Dark mode</button>
            </div>
            {% endif %}
          </div>
        </div>
      </header>
      <main class="content container">
        {% block content %}{% endblock %}
      </main>
      <footer class="site-footer">
        <div class="container footer-inner">Single-host secure storage</div>
      </footer>
    </div>
    {% block scripts %}{% endblock %}
    <script>
      const root = document.body;
      const toggle = document.getElementById("themeToggle");
      const stored = localStorage.getItem("pfv-theme");
      if (stored) {
        root.dataset.theme = stored;
        toggle.textContent = stored === "dark" ? "Light mode" : "Dark mode";
      }

      toggle.addEventListener("click", () => {
        const next = root.dataset.theme === "dark" ? "light" : "dark";
        root.dataset.theme = next;
        localStorage.setItem("pfv-theme", next);
        toggle.textContent = next === "dark" ? "Light mode" : "Dark mode";
      });

      const toolbar = document.querySelector(".toolbar");
      const nav = document.getElementById("pfvPrimaryNav");
      const menuToggle = document.getElementById("pfvMenuToggle");
      const mobileQuery = window.matchMedia("(max-width: 760px)");
      const MENU_STATE_KEY = "pfv-mobile-menu-open";

      function setMenuState(open) {
        if (!toolbar || !menuToggle) return;
        const isOpen = !!open;
        toolbar.dataset.menuOpen = isOpen ? "1" : "0";
        menuToggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
        menuToggle.textContent = isOpen ? "Close menu" : "Menu";
      }

      function syncMenuState() {
        if (!toolbar || !menuToggle) return;
        if (!mobileQuery.matches) {
          toolbar.dataset.menuOpen = "1";
          menuToggle.setAttribute("aria-expanded", "false");
          menuToggle.textContent = "Menu";
          return;
        }
        const stored = localStorage.getItem(MENU_STATE_KEY);
        setMenuState(stored === "1");
      }

      if (menuToggle && toolbar && nav) {
        menuToggle.addEventListener("click", () => {
          if (!mobileQuery.matches) return;
          const nextOpen = toolbar.dataset.menuOpen !== "1";
          setMenuState(nextOpen);
          localStorage.setItem(MENU_STATE_KEY, nextOpen ? "1" : "0");
        });

        nav.addEventListener("click", (event) => {
          const target = event.target instanceof Element ? event.target.closest("a, button") : null;
          if (!target || !mobileQuery.matches) return;
          setMenuState(false);
          localStorage.setItem(MENU_STATE_KEY, "0");
        });

        if (typeof mobileQuery.addEventListener === "function") {
          mobileQuery.addEventListener("change", syncMenuState);
        } else if (typeof mobileQuery.addListener === "function") {
          mobileQuery.addListener(syncMenuState);
        }

        syncMenuState();
      }

      const navGroupsLink = document.getElementById("pfvNavGroupsLink");
      const navGroupsBadge = document.getElementById("pfvNavBadgeGroups");
      let notificationsTimer = null;

      async function refreshNotifications() {
        if (!navGroupsBadge || !navGroupsLink) return;
        try {
          const response = await fetch("/ui/notifications", { credentials: "same-origin", cache: "no-store" });
          if (!response.ok) {
            if (response.status === 401) {
              navGroupsBadge.hidden = true;
            }
            return;
          }
          const payload = await response.json();
          const unreadMessages = Number(payload.unread_messages || 0);
          const pendingInvites = Number(payload.pending_group_invites || 0);
          const total = Number(payload.groups_badge_total || 0);
          navGroupsLink.title = `${unreadMessages} unread messages, ${pendingInvites} pending invites`;
          if (total > 0) {
            navGroupsBadge.hidden = false;
            navGroupsBadge.textContent = total > 99 ? "99+" : String(total);
          } else {
            navGroupsBadge.hidden = true;
            navGroupsBadge.textContent = "0";
          }
        } catch {
          return;
        }
      }

      if (navGroupsBadge && navGroupsLink) {
        refreshNotifications();
        notificationsTimer = window.setInterval(refreshNotifications, 15000);
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) refreshNotifications();
        });
        window.addEventListener(
          "beforeunload",
          () => {
            if (notificationsTimer) {
              clearInterval(notificationsTimer);
            }
          },
          { once: true }
        );
      }
    </script>

    {% if user %}
    <div class="terminal" id="pfvTerminal" data-open="1" data-max="0" data-theme="dark" data-status="syncing">
      <div class="terminal-bar">
        <div class="terminal-left">
          <span class="terminal-badge">Live</span>
          <span class="terminal-title">Vault Activity Console</span>
        </div>
        <div class="terminal-actions">
          <button type="button" class="terminal-control" id="pfvTerminalMinimize" aria-label="Minimize terminal" title="Minimize">MIN</button>
          <button type="button" class="terminal-control" id="pfvTerminalMaximize" aria-label="Maximize terminal" title="Maximize">MAX</button>
          <button type="button" class="terminal-control terminal-control-close" id="pfvTerminalClose" aria-label="Close terminal" title="Close">CLOSE</button>
          <button type="button" class="ghost" id="pfvTerminalToggle">Hide</button>
          <button type="button" class="ghost" id="pfvTerminalClear">Clear</button>
        </div>
      </div>
      <div class="terminal-meta">
        <div class="terminal-metric"><span class="metric-key">Status</span><span class="metric-value" id="pfvTerminalStatus">SYNCING</span></div>
        <div class="terminal-metric"><span class="metric-key">Events</span><span class="metric-value" id="pfvTerminalEventCount">0</span></div>
        <div class="terminal-metric"><span class="metric-key">Scroll</span><span class="metric-value" id="pfvTerminalScrollState">AUTO</span></div>
      </div>
      <div class="terminal-body" id="pfvTerminalBody" role="log" aria-live="polite" aria-relevant="additions"></div>
      <div class="terminal-shortcuts" id="pfvTerminalShortcuts">
        <button type="button" class="terminal-shortcut" data-cmd="help">help</button>
        <button type="button" class="terminal-shortcut" data-cmd="scope">scope</button>
        <button type="button" class="terminal-shortcut" data-cmd="groups">groups</button>
        <button type="button" class="terminal-shortcut" data-cmd="list">list</button>
        <button type="button" class="terminal-shortcut" data-cmd="tree">tree</button>
        <button type="button" class="terminal-shortcut" data-cmd="find">find</button>
        <button type="button" class="terminal-shortcut" data-cmd="stat">stat</button>
        <button type="button" class="terminal-shortcut" data-cmd="quota">quota</button>
        <button type="button" class="terminal-shortcut" data-cmd="encstatus">encstatus</button>
        <button type="button" class="terminal-shortcut" data-cmd="encproof">encproof</button>
        <button type="button" class="terminal-shortcut" data-cmd="directory">directory</button>
      </div>
      <form class="terminal-input" id="pfvTerminalForm">
        <span class="terminal-prompt" aria-hidden="true">vault$</span>
        <input type="text" id="pfvTerminalCommand" name="command" placeholder="Type: help, list, tree, find, stat, view, hash, quota, encstatus" autocomplete="off" />
        <button type="submit">Execute</button>
      </form>
      <span class="resize-handle handle-e" data-resize="e"></span>
      <span class="resize-handle handle-w" data-resize="w"></span>
      <span class="resize-handle handle-n" data-resize="n"></span>
      <span class="resize-handle handle-s" data-resize="s"></span>
    </div>
    <script>
      (function () {
        const term = document.getElementById("pfvTerminal");
        const body = document.getElementById("pfvTerminalBody");
        const toggleBtn = document.getElementById("pfvTerminalToggle");
        const clearBtn = document.getElementById("pfvTerminalClear");
        const closeDot = document.getElementById("pfvTerminalClose");
        const minDot = document.getElementById("pfvTerminalMinimize");
        const maxDot = document.getElementById("pfvTerminalMaximize");
        const navTab = document.getElementById("pfvTerminalNav");
        const termForm = document.getElementById("pfvTerminalForm");
        const termCommand = document.getElementById("pfvTerminalCommand");
        const terminalStatus = document.getElementById("pfvTerminalStatus");
        const terminalEventCount = document.getElementById("pfvTerminalEventCount");
        const terminalScrollState = document.getElementById("pfvTerminalScrollState");
        const terminalShortcuts = document.querySelectorAll(".terminal-shortcut");
        if (!term || !body || !toggleBtn || !clearBtn || !closeDot || !minDot || !maxDot) return;
        const VIEW_MARGIN = 12;
        const DESKTOP_MIN_WIDTH = 360;
        const DESKTOP_MIN_HEIGHT = 220;
        const TERMINAL_BODY_MIN_HEIGHT = 64;
        const TERMINAL_LAYOUT_VERSION = "2";

        if (localStorage.getItem("pfv-terminal-layout-version") !== TERMINAL_LAYOUT_VERSION) {
          localStorage.removeItem("pfv-terminal-pos");
          localStorage.removeItem("pfv-terminal-size");
          localStorage.removeItem("pfv-terminal-max");
          localStorage.removeItem("pfv-terminal-premax");
          localStorage.setItem("pfv-terminal-layout-version", TERMINAL_LAYOUT_VERSION);
        }

        function pxToNumber(value) {
          if (typeof value !== "string" || !value) return null;
          const parsed = Number.parseFloat(value);
          return Number.isFinite(parsed) ? parsed : null;
        }

        function viewportBounds() {
          const vv = window.visualViewport;
          const width = Math.max((vv ? vv.width : window.innerWidth) || 0, 320);
          const height = Math.max((vv ? vv.height : window.innerHeight) || 0, 240);
          return {
            width,
            height,
            availableWidth: Math.max(220, width - VIEW_MARGIN * 2),
            availableHeight: Math.max(160, height - VIEW_MARGIN * 2),
          };
        }

        function minTerminalWidth(availableWidth) {
          return Math.min(DESKTOP_MIN_WIDTH, availableWidth);
        }

        function terminalChromeHeight() {
          if (term.dataset.open !== "1") return 0;
          const barHeight = term.querySelector(".terminal-bar")?.getBoundingClientRect().height || 0;
          const metaHeight = term.querySelector(".terminal-meta")?.getBoundingClientRect().height || 0;
          const shortcutsHeight = term.querySelector(".terminal-shortcuts")?.getBoundingClientRect().height || 0;
          const inputHeight = term.querySelector(".terminal-input")?.getBoundingClientRect().height || 0;
          return barHeight + metaHeight + shortcutsHeight + inputHeight;
        }

        function minTerminalHeight(availableHeight) {
          const dynamic = Math.ceil(terminalChromeHeight() + TERMINAL_BODY_MIN_HEIGHT);
          const preferred = Math.max(DESKTOP_MIN_HEIGHT, dynamic);
          return Math.min(preferred, availableHeight);
        }

        function persistTerminalFrame(rect = term.getBoundingClientRect()) {
          if (term.dataset.max === "1") return;
          localStorage.setItem(
            "pfv-terminal-pos",
            JSON.stringify({ left: Math.round(rect.left), top: Math.round(rect.top) })
          );
          localStorage.setItem(
            "pfv-terminal-size",
            JSON.stringify({ width: Math.round(rect.width), height: Math.round(rect.height) })
          );
        }

        function clampTerminalFrame({ persist = true } = {}) {
          if (term.dataset.max === "1") return;
          const { width: viewportWidth, height: viewportHeight, availableWidth, availableHeight } = viewportBounds();
          const minWidth = minTerminalWidth(availableWidth);
          const rect = term.getBoundingClientRect();

          let width = pxToNumber(term.style.width);
          let height = pxToNumber(term.style.height);
          if (width === null || width <= 0) {
            width = rect.width > 0 ? rect.width : Math.min(860, availableWidth);
          }
          if (height === null || height <= 0) {
            height = rect.height > 0 ? rect.height : Math.min(420, availableHeight);
          }

          width = Math.min(Math.max(width, minWidth), availableWidth);
          term.style.width = `${Math.round(width)}px`;
          const minHeight = minTerminalHeight(availableHeight);
          height = Math.min(Math.max(height, minHeight), availableHeight);

          let left = pxToNumber(term.style.left);
          let top = pxToNumber(term.style.top);
          if (left === null) {
            left = rect.width > 0 ? rect.left : viewportWidth - width - VIEW_MARGIN;
          }
          if (top === null) {
            top = rect.height > 0 ? rect.top : viewportHeight - height - VIEW_MARGIN;
          }

          const maxLeft = Math.max(VIEW_MARGIN, viewportWidth - width - VIEW_MARGIN);
          const maxTop = Math.max(VIEW_MARGIN, viewportHeight - height - VIEW_MARGIN);
          left = Math.min(Math.max(left, VIEW_MARGIN), maxLeft);
          top = Math.min(Math.max(top, VIEW_MARGIN), maxTop);

          term.style.width = `${Math.round(width)}px`;
          term.style.height = `${Math.round(height)}px`;
          term.style.left = `${Math.round(left)}px`;
          term.style.top = `${Math.round(top)}px`;
          term.style.right = "auto";
          term.style.bottom = "auto";
          if (persist) persistTerminalFrame();
        }

        const openStored = localStorage.getItem("pfv-terminal-open");
        if (openStored === "0" || openStored === "1") {
          term.dataset.open = openStored;
        } else if (window.matchMedia("(max-width: 760px)").matches) {
          term.dataset.open = "0";
          localStorage.setItem("pfv-terminal-open", "0");
        }
        term.dataset.min = term.dataset.open === "1" ? "0" : "1";
        const maxStored = localStorage.getItem("pfv-terminal-max");
        if (maxStored === "0" || maxStored === "1") {
          term.dataset.max = maxStored;
        }
        const posStored = localStorage.getItem("pfv-terminal-pos");
        if (posStored) {
          try {
            const pos = JSON.parse(posStored);
            if (typeof pos.left === "number" && typeof pos.top === "number") {
              term.style.left = `${pos.left}px`;
              term.style.top = `${pos.top}px`;
              term.style.right = "auto";
              term.style.bottom = "auto";
            }
          } catch {}
        }
        const sizeStored = localStorage.getItem("pfv-terminal-size");
        if (sizeStored) {
          try {
            const size = JSON.parse(sizeStored);
            if (typeof size.width === "number" && typeof size.height === "number") {
              term.style.width = `${size.width}px`;
              term.style.height = `${size.height}px`;
            }
          } catch {}
        }
        requestAnimationFrame(() => clampTerminalFrame({ persist: false }));

        function syncTerminalUi() {
          const isOpen = term.dataset.open === "1";
          toggleBtn.textContent = "Hide";
          toggleBtn.style.display = isOpen ? "inline-flex" : "none";
          term.dataset.min = isOpen ? "0" : "1";
          if (isOpen && term.dataset.max !== "1") {
            requestAnimationFrame(() => clampTerminalFrame({ persist: false }));
          }
          if (navTab) {
            navTab.textContent = isOpen ? "Hide Terminal" : "Terminal";
          }
        }

        syncTerminalUi();
        let renderedEvents = 0;
        function setStatus(value) {
          const normalized = (value || "LIVE").toUpperCase();
          if (terminalStatus) terminalStatus.textContent = normalized;
          term.dataset.status = normalized.toLowerCase();
        }

        toggleBtn.addEventListener("click", () => {
          term.dataset.open = "0";
          localStorage.setItem("pfv-terminal-open", "0");
          syncTerminalUi();
        });

        clearBtn.addEventListener("click", () => {
          body.innerHTML = "";
          renderedEvents = 0;
          lastDateLabel = "";
          if (terminalEventCount) terminalEventCount.textContent = "0";
        });

        closeDot.addEventListener("click", () => {
          term.dataset.open = "0";
          localStorage.setItem("pfv-terminal-open", "0");
          syncTerminalUi();
        });

        navTab?.addEventListener("click", () => {
          const next = term.dataset.open === "1" ? "0" : "1";
          term.dataset.open = next;
          localStorage.setItem("pfv-terminal-open", next);
          syncTerminalUi();
        });

        minDot.addEventListener("click", () => {
          if (term.dataset.max === "1") {
            term.dataset.max = "0";
            localStorage.setItem("pfv-terminal-max", "0");
            const premax = localStorage.getItem("pfv-terminal-premax");
            if (premax) {
              try {
                const pos = JSON.parse(premax);
                if (typeof pos.left === "number") term.style.left = `${pos.left}px`;
                if (typeof pos.top === "number") term.style.top = `${pos.top}px`;
                if (typeof pos.width === "number") term.style.width = `${pos.width}px`;
                if (typeof pos.height === "number") term.style.height = `${pos.height}px`;
                term.style.right = "auto";
                term.style.bottom = "auto";
              } catch {}
            }
          }
          term.dataset.open = "0";
          term.dataset.min = "1";
          localStorage.setItem("pfv-terminal-open", "0");
          syncTerminalUi();
        });

        maxDot.addEventListener("click", () => {
          const next = term.dataset.max === "1" ? "0" : "1";
          if (next === "1") {
            const rect = term.getBoundingClientRect();
            localStorage.setItem(
              "pfv-terminal-premax",
              JSON.stringify({
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height,
              })
            );
          }
          term.dataset.max = next;
          localStorage.setItem("pfv-terminal-max", next);
          if (term.dataset.open !== "1") {
            term.dataset.open = "1";
            localStorage.setItem("pfv-terminal-open", "1");
          }
          if (next === "1") {
            term.style.left = "";
            term.style.top = "";
            term.style.right = "";
            term.style.bottom = "";
            term.style.width = "";
            term.style.height = "";
          } else {
            const premax = localStorage.getItem("pfv-terminal-premax");
            if (premax) {
              try {
                const pos = JSON.parse(premax);
                if (typeof pos.left === "number") term.style.left = `${pos.left}px`;
                if (typeof pos.top === "number") term.style.top = `${pos.top}px`;
                if (typeof pos.width === "number") term.style.width = `${pos.width}px`;
                if (typeof pos.height === "number") term.style.height = `${pos.height}px`;
                term.style.right = "auto";
                term.style.bottom = "auto";
              } catch {}
            }
          }
          syncTerminalUi();
        });

        let autoScroll = true;
        body.addEventListener("scroll", () => {
          autoScroll = body.scrollTop + body.clientHeight >= body.scrollHeight - 8;
          if (terminalScrollState) {
            terminalScrollState.textContent = autoScroll ? "AUTO" : "MANUAL";
          }
        });

        function fmtTs(iso) {
          try {
            const d = new Date(iso);
            return d.toLocaleTimeString([], { hour12: false });
          } catch {
            return iso;
          }
        }

        function fmtDate(iso) {
          try {
            const d = new Date(iso);
            return d.toLocaleDateString([], { year: "numeric", month: "short", day: "2-digit" });
          } catch {
            return "";
          }
        }

        let lastDateLabel = "";

        function appendEvent(evt) {
          const dateLabel = fmtDate(evt.ts || new Date().toISOString());
          if (dateLabel && dateLabel !== lastDateLabel) {
            const divider = document.createElement("div");
            divider.className = "terminal-line terminal-date";
            divider.textContent = dateLabel;
            body.appendChild(divider);
            lastDateLabel = dateLabel;
          }

          const line = document.createElement("div");
          line.className = `terminal-line level-${(evt.level || "INFO").toLowerCase()}`;

          const ts = document.createElement("span");
          ts.className = "terminal-ts";
          ts.textContent = `[${fmtTs(evt.ts || new Date().toISOString())}]`;

          const action = document.createElement("span");
          action.className = "terminal-action";
          action.textContent = `${evt.action || "system"}:`;

          const msg = document.createElement("span");
          msg.className = "terminal-msg";
          msg.textContent = evt.message || "";

          line.append(ts, action, msg);
          body.appendChild(line);
          renderedEvents += 1;
          if (terminalEventCount) terminalEventCount.textContent = String(renderedEvents);

          if (autoScroll) {
            body.scrollTop = body.scrollHeight;
          }
        }

        termForm?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const raw = termCommand?.value || "";
          if (!raw.trim()) return;
          appendEvent({ level: "INFO", action: "cmd", message: raw });
          if (termCommand) termCommand.value = "";
          setStatus("RUNNING");
          try {
            const res = await fetch("/ui/terminal", {
              method: "POST",
              headers: { "Content-Type": "application/x-www-form-urlencoded" },
              body: new URLSearchParams({ command: raw }),
            });
            const data = await res.json();
            if (!res.ok) {
              appendEvent({ level: "ERROR", action: "cmd", message: data.detail || "Command failed" });
            } else {
              appendEvent({ level: "SUCCESS", action: "cmd", message: data.message || "OK" });
            }
            setStatus("LIVE");
          } catch {
            appendEvent({ level: "ERROR", action: "cmd", message: "Terminal command failed to send." });
            setStatus("OFFLINE");
          }
        });

        terminalShortcuts.forEach((shortcut) => {
          shortcut.addEventListener("click", () => {
            const cmd = shortcut.dataset.cmd || "";
            if (!termCommand) return;
            termCommand.value = cmd;
            termCommand.focus();
            termCommand.select();
          });
        });

        termCommand?.addEventListener("keydown", async (e) => {
          if (e.key !== "Tab") return;
          e.preventDefault();
          const value = termCommand.value;
          const parts = value.split(/\s+/);
          if (parts.length === 0) return;
          const current = parts[parts.length - 1] || "";
          try {
            const res = await fetch(`/ui/terminal/suggest?prefix=${encodeURIComponent(current)}`, {
              cache: "no-store",
              credentials: "same-origin",
            });
            const data = await res.json();
            const suggestions = data.suggestions || [];
            if (suggestions.length === 1) {
              parts[parts.length - 1] = suggestions[0];
              termCommand.value = parts.join(" ") + (suggestions[0].endsWith("/") ? "" : " ");
            } else if (suggestions.length > 1) {
              appendEvent({
                level: "INFO",
                action: "suggest",
                message: suggestions.join("  "),
              });
            }
          } catch {
            appendEvent({ level: "ERROR", action: "suggest", message: "Autocomplete failed." });
          }
        });

        let afterId = Number(sessionStorage.getItem("pfv-terminal-after") || 0);
        let signInNotified = false;

        async function poll(url) {
          try {
            const res = await fetch(url, {
              credentials: "same-origin",
              headers: { Accept: "application/json" },
              cache: "no-store",
            });
            if (!res.ok) {
              if (res.status === 401) {
                setStatus("AUTH");
                if (!signInNotified) {
                  signInNotified = true;
                  appendEvent({ level: "INFO", action: "system", message: "Sign in to see activity." });
                }
              }
              return;
            }
            setStatus("LIVE");
            const data = await res.json();
            const events = data.events || [];
            for (const evt of events) appendEvent(evt);
            if (events.length) {
              afterId = events[events.length - 1].id;
              sessionStorage.setItem("pfv-terminal-after", String(afterId));
            }
            if (signInNotified) {
              signInNotified = false;
            }
          } catch {
            // Ignore transient network errors in the UI terminal.
            setStatus("OFFLINE");
          }
        }

        // Theme sync for terminal
        function syncTerminalTheme() {
          term.dataset.theme = document.body.dataset.theme || "light";
        }
        syncTerminalTheme();
        const themeObserver = new MutationObserver(syncTerminalTheme);
        themeObserver.observe(document.body, { attributes: true, attributeFilter: ["data-theme"] });

        // Drag support (disabled when maximized)
        let dragActive = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let originLeft = 0;
        let originTop = 0;

        function onDragStart(e) {
          if (term.dataset.max === "1") return;
          const target = e.target;
          if (target.closest(".terminal-actions")) return;
          dragActive = true;
          const rect = term.getBoundingClientRect();
          originLeft = rect.left;
          originTop = rect.top;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          term.classList.add("dragging");
          document.addEventListener("mousemove", onDragMove);
          document.addEventListener("mouseup", onDragEnd);
        }

        function onDragMove(e) {
          if (!dragActive) return;
          const dx = e.clientX - dragStartX;
          const dy = e.clientY - dragStartY;
          const rect = term.getBoundingClientRect();
          const width = rect.width || minTerminalWidth(viewportBounds().availableWidth);
          const height = rect.height || minTerminalHeight(viewportBounds().availableHeight);
          const { width: viewportWidth, height: viewportHeight } = viewportBounds();
          const maxLeft = Math.max(VIEW_MARGIN, viewportWidth - width - VIEW_MARGIN);
          const maxTop = Math.max(VIEW_MARGIN, viewportHeight - height - VIEW_MARGIN);
          const left = Math.max(VIEW_MARGIN, Math.min(maxLeft, originLeft + dx));
          const top = Math.max(VIEW_MARGIN, Math.min(maxTop, originTop + dy));
          term.style.left = `${left}px`;
          term.style.top = `${top}px`;
          term.style.right = "auto";
          term.style.bottom = "auto";
        }

        function onDragEnd() {
          dragActive = false;
          term.classList.remove("dragging");
          document.removeEventListener("mousemove", onDragMove);
          document.removeEventListener("mouseup", onDragEnd);
          clampTerminalFrame({ persist: true });
        }

        term.querySelector(".terminal-bar")?.addEventListener("mousedown", onDragStart);

        // Resize support (sides + top/bottom)
        const handles = term.querySelectorAll(".resize-handle");
        let resizeActive = false;
        let resizeDir = "";
        let startW = 0;
        let startH = 0;
        let startX = 0;
        let startY = 0;
        let startLeft = 0;
        let startTop = 0;

        function onResizeStart(e) {
          if (term.dataset.max === "1") return;
          resizeActive = true;
          resizeDir = e.target.dataset.resize || "";
          const rect = term.getBoundingClientRect();
          startW = rect.width;
          startH = rect.height;
          startLeft = rect.left;
          startTop = rect.top;
          startX = e.clientX;
          startY = e.clientY;
          document.addEventListener("mousemove", onResizeMove);
          document.addEventListener("mouseup", onResizeEnd);
          e.preventDefault();
          e.stopPropagation();
        }

        function onResizeMove(e) {
          if (!resizeActive) return;
          const { availableWidth, availableHeight } = viewportBounds();
          const minWidth = minTerminalWidth(availableWidth);
          const minHeight = minTerminalHeight(availableHeight);
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          let newW = startW;
          let newH = startH;
          let newLeft = startLeft;
          let newTop = startTop;

          if (resizeDir.includes("e")) {
            newW = Math.max(minWidth, startW + dx);
          }
          if (resizeDir.includes("w")) {
            newW = Math.max(minWidth, startW - dx);
            newLeft = startLeft + dx;
          }
          if (resizeDir.includes("s")) {
            newH = Math.max(minHeight, startH + dy);
          }
          if (resizeDir.includes("n")) {
            newH = Math.max(minHeight, startH - dy);
            newTop = startTop + dy;
          }

          term.style.width = `${newW}px`;
          term.style.height = `${newH}px`;
          term.style.left = `${newLeft}px`;
          term.style.top = `${newTop}px`;
          term.style.right = "auto";
          term.style.bottom = "auto";
          clampTerminalFrame({ persist: false });
        }

        function onResizeEnd() {
          resizeActive = false;
          document.removeEventListener("mousemove", onResizeMove);
          document.removeEventListener("mouseup", onResizeEnd);
          clampTerminalFrame({ persist: true });
        }

        handles.forEach((h) => h.addEventListener("mousedown", onResizeStart));
        window.addEventListener("resize", () => {
          clampTerminalFrame({ persist: true });
        });

        async function bootstrapActivity() {
          setStatus("SYNCING");
          try {
            const res = await fetch("/ui/activity?no_history=1&redact=1", {
              credentials: "same-origin",
              headers: { Accept: "application/json" },
              cache: "no-store",
            });
            if (res.ok) {
              const data = await res.json();
              afterId = Number(data.last_id || 0);
              sessionStorage.setItem("pfv-terminal-after", String(afterId));
              setStatus("LIVE");
            }
          } catch {
            // Ignore bootstrap errors.
            setStatus("OFFLINE");
          }
        }

        bootstrapActivity().finally(() => {
          setInterval(() => {
            poll(`/ui/activity?after_id=${afterId}&limit=200&redact=1`);
          }, 1000);
        });
      })();
    </script>
    {% endif %}
  </body>
</html>
